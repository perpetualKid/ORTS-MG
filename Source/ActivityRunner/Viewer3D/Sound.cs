// COPYRIGHT 2009, 2010, 2011, 2012, 2013, 2014, 2015 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

// This file is the responsibility of the 3D & Environment Team. 

// ORTS SOUND SYSTEM
// 
// Sounds are generated by SoundSource objects.   All sound-making items, ie scenery, railcars, etc 
// create a SoundSource object, passing it the MSTS SMS file that specifies the sound.
// SoundSource objects
//  - have a physical location in the world, 
//  - may be attached to a railcar in which case it moves with the car
//  - railcar-attached sounds can poll control variables in the simulator
//  - have one or more SoundStreams
//  SoundStreams
//  - can play only one sound at a time
//  - the sound played is controlled by the various triggers
//  SoundTriggers
//  - defined in the SMS file
//  - triggered by various events
//  - when triggered, executes a SoundCommand
//  SoundCommands
//  - used by triggers to control the SoundStream
//  - ie play a sound, stop a sound etc

//#define DEBUGSCR

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Orts.ActivityRunner.Viewer3D.Sound;
using Orts.Common;
using Orts.Common.Position;
using Orts.Formats.Msts;
using Orts.Formats.Msts.Files;
using Orts.Formats.Msts.Models;
using Orts.Settings;
using Orts.Simulation;
using Orts.Simulation.AIs;
using Orts.Simulation.RollingStocks;
using Orts.Simulation.Signalling;

namespace Orts.ActivityRunner.Viewer3D
{

    /// <summary>
    /// Utility class to avoid loading multiple copies of the same file.
    /// </summary>
    public class SharedSMSFileManager
    {
        private static Dictionary<string, SoundManagmentFile> sharedSMSFiles = new Dictionary<string, SoundManagmentFile>();

        public static int SwitchSmsNumber { get; private set; }
        public static int CurveSmsNumber { get; private set; }
        public static int CurveSwitchSmsNumber { get; private set; }
        public static bool AutoTrackSound { get; private set; }

        public static SoundManagmentFile Get(string path)
        {
            if (!sharedSMSFiles.ContainsKey(path))
            {
                SoundManagmentFile smsFile = new SoundManagmentFile(path);
                sharedSMSFiles.Add(path, smsFile);
            }
            return sharedSMSFiles[path];
        }

        public static void Initialize(int trackTypesNumber, int switchSmsNumber, int curveSmsNumber, int curveSwitchSmsNumber)
        {
            SwitchSmsNumber = switchSmsNumber;

            if (SwitchSmsNumber < -1 || SwitchSmsNumber >= trackTypesNumber)
            {
                SwitchSmsNumber = -1;
                Trace.TraceInformation("Switch SMS Number out of range");
            }
            if (SwitchSmsNumber != -1)
                AutoTrackSound = true;

            CurveSmsNumber = curveSmsNumber;
            if (CurveSmsNumber < -1 || CurveSmsNumber >= trackTypesNumber)
            {
                CurveSmsNumber = -1;
                Trace.TraceInformation("Curve SMS Number out of range");
            }
            if (CurveSmsNumber != -1)
                AutoTrackSound = true;

            CurveSwitchSmsNumber = curveSwitchSmsNumber;
            if (CurveSwitchSmsNumber < -1 || CurveSwitchSmsNumber >= trackTypesNumber)
            {
                CurveSwitchSmsNumber = CurveSmsNumber;
                Trace.TraceInformation("CurveSwitch SMS Number out of range, replaced with curve SMS number");
            }
            if (CurveSwitchSmsNumber != -1)
                AutoTrackSound = true;

        }
    }

    /////////////////////////////////////////////////////////
    // SOUND SOURCE
    /////////////////////////////////////////////////////////

    /// <summary>
    /// Represents an sms file,
    /// may have a physical location in the world,
    /// may be attached to a railcar in which case it moves with the car,
    /// owns one or more SoundStreams
    /// </summary>
    public abstract class SoundSourceBase : IDisposable
    {
        public abstract void InitInitials();
        public abstract void Uninitialize();
        public abstract bool Update();

        /// <summary>
        /// The sound may be from a train car
        /// </summary>
        public MSTSWagon Car;
        /// <summary>
        /// The listener is connected to this viewer
        /// </summary>
        public Viewer Viewer;
        /// <summary>
        /// Volume of the ScalabiltyGroup
        /// </summary>
        public float Volume = 1;
        /// <summary>
        /// If needs active management or can be left to OpenAL to deal with sound properties
        /// </summary>
        public bool NeedsFrequentUpdate;
        public bool TrackSound;

        public abstract void Dispose();
    }

    public class TrackSoundSource : SoundSourceBase
    {
        private int _prevTType = -1;
        private int _curTType = -1;
        public SoundSource _activeInSource;
        public SoundSource _activeOutSource;
        private List<SoundSource> _inSources;
        private List<SoundSource> _outSources;

        // data to evaluate if ttype selection is needed or not
        private float nextDist = -1; // initial distance to sound region forward
        private float prevDist = -1; // initial distance to sond region backward
        private float initDist = -1; // initial distance run when last ttype selected
        private int initTrackSection = -1; // track section when last ttype selected
        private MSTSWagon initCar; // initial leading car (to accommodate in case of change of direction)
        private bool CarOnSwitch;
        private bool CarOnCurve;


        public TrackSoundSource(MSTSWagon car, Viewer viewer)
        {
            TrackSound = true;
            Car = car;
            Viewer = viewer;
            _inSources = new List<SoundSource>();
            _outSources = new List<SoundSource>();

            foreach (TrackType ttdf in viewer.TrackTypes)
            {
                MSTSLocomotive loco = Car as MSTSLocomotive;

                //if (!string.IsNullOrEmpty(Car.InteriorSoundFileName) || (loco != null && !string.IsNullOrEmpty(loco.CabSoundFileName)))
                if (!string.IsNullOrEmpty(Car.InteriorShapeFileName) || (loco != null && (loco.HasFrontCab || loco.HasRearCab || loco.HasFront3DCab || loco.HasRear3DCab)))
                    LoadTrackSound(ttdf.InsideSound, true);

                LoadTrackSound(ttdf.OutsideSound, false);
            }

        }

        private void LoadTrackSound(string filename, bool isInside)
        {
            if (filename == null)
                return;

            string[] pathArray = { Viewer.Simulator.RouteFolder.SoundFolder, Viewer.Simulator.RouteFolder.ContentFolder.SoundFolder };
            var fullPath = FolderStructure.FindFileFromFolders(pathArray, filename);
            if (fullPath == null)
            {
                Trace.TraceWarning("Skipped missing track sound {0}", filename);
                return;
            }
            if (isInside)
                _inSources.Add(new SoundSource(Viewer, Car, fullPath));
            else
                _outSources.Add(new SoundSource(Viewer, Car, fullPath));
        }

        public override void Uninitialize()
        {
            //Trace.TraceInformation("TrackSoundSource Uninitialize");
            if (_activeInSource != null)
                _activeInSource.Uninitialize();
            if (_activeOutSource !=null)
                _activeOutSource.Uninitialize();
        }

        public override void InitInitials()
        {
            if (_inSources != null && _inSources.Count > 0)
                _activeInSource = _inSources[0];

            if (_outSources != null && _outSources.Count > 0)
                _activeOutSource = _outSources[0];

            _curTType = 0;
            _prevTType = 0;
        }

        public void UpdateTType(bool stateChange)
        {
            if (_prevTType == -1)
            {
                InitInitials();
            }

            if (Car != null && Car.Train != null)
            {
                int CarIncr = 0;
                int CarLeading = 0;
                if (Car.Train.SpeedMpS > 0.1f)
                {
                    CarIncr = 1;
                    CarLeading = 0;
                }
                else
                    if (Car.Train.SpeedMpS < -0.1f)
                    {
                        CarIncr = -1;
                        CarLeading = Car.Train.Cars.Count - 1;
                    }
                    else
                        return;

                var CarNo = Car.Train.Cars.IndexOf(Car);
                float trackSoundDistSquared = 0;

                if (CarNo == CarLeading)
                {
                    bool reSelect = stateChange;
                    if (!reSelect)
                    {
                        if (nextDist == -1 || initCar != Car.Train.Cars[CarLeading])
                        {
                            reSelect = true;
                        }
                        else if ((CarLeading == 0 && Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex != initTrackSection) || (CarLeading != 0 && Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex != initTrackSection))
                        {
                            reSelect = true;
                        }
                        else if (CarLeading == 0 && (Car.Train.DistanceTravelledM - initDist > nextDist || initDist - Car.Train.DistanceTravelledM > prevDist))
                        {
                            reSelect = true;
                        }
                        else if (CarLeading != 0 && (Car.Train.DistanceTravelledM - Car.Train.Length - initDist > nextDist || initDist - Car.Train.DistanceTravelledM + Car.Train.Length > prevDist))
                        {
                            reSelect = true;
                        }
                    }
                    if (reSelect)
                    {
                        //_curTType = Viewer.WorldSounds.GetTType(_tdbObjs);
                        initCar = Car;
                        initTrackSection = CarLeading == 0 ? Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex : Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex;
                        initDist = CarLeading == 0 ? Car.Train.DistanceTravelledM : Car.Train.DistanceTravelledM - Car.Train.Length;
                        Car.TrackSoundType = Viewer.World.Sounds.GetTType(Car.Train, out prevDist, out nextDist);
                        if (Car.TrackSoundType != int.MaxValue)
                            if (Car.TrackSoundType < Viewer.TrackTypes.Count)
                                _curTType = Car.TrackSoundType;
                            else
                            {
                                // Track type out of range
                                _curTType = 0;
                                Trace.TraceWarning("Sound region {0} out of range in tile {1} {2}", Car.TrackSoundType,
                                    Car.WorldPosition.WorldLocation.TileX, Car.WorldPosition.WorldLocation.TileZ);
                                Car.TrackSoundType = 0;
                            }
                        else
                            if (!SharedSMSFileManager.AutoTrackSound || (
                                _curTType != SharedSMSFileManager.SwitchSmsNumber &&
                                _curTType != SharedSMSFileManager.CurveSmsNumber &&
                                _curTType != SharedSMSFileManager.CurveSwitchSmsNumber))
                                Car.TrackSoundType = _curTType;
                            else
                            {
                                Car.TrackSoundType = 0;
                                _curTType = 0;
                            }
                     }
                    else Car.TrackSoundType = _curTType;
                }
                else
                {
                    var CarAhead = Car.Train.Cars[CarNo - CarIncr];
                    if (CarAhead.TrackSoundLocation != WorldLocation.None)
                    {
//                        if (stateChange)
//                            Trace.TraceInformation("Time {4} TrainName {6} carNo {0} IsOnSwitch {1} IsOnCurve {7} TracksoundType {2} _CurTType {3} AheadTrackSoundType {5}",
//                                Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, CarAhead.TrackSoundType, Car.Train.Name, CarOnCurve);
                        if ((_curTType == Car.TrackSoundType || stateChange ) && Car.TrackSoundType != CarAhead.TrackSoundType)
                        {
                            Car.TrackSoundType = CarAhead.TrackSoundType;
                            Car.TrackSoundLocation = CarAhead.TrackSoundLocation;
                            Car.TrackSoundDistSquared = (float)WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, Car.TrackSoundLocation);
//                            Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} to standard",
//                              Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve);
                            if (stateChange)
                            {
                                _curTType = Car.TrackSoundType;
                            }
                        }

                        if (Car.TrackSoundLocation != WorldLocation.None)
                        {
                            trackSoundDistSquared = (float)WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, Car.TrackSoundLocation);
                            if (trackSoundDistSquared > 9 && (trackSoundDistSquared - 2) <= Car.TrackSoundDistSquared)
                                Car.TrackSoundDistSquared = trackSoundDistSquared;
                            else
                            {
//                                if (_curTType != Car.TrackSoundType) Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} standard",
//                                  Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve);
                                _curTType = Car.TrackSoundType;
                            }
                        }
                    }
                }

                //if (_curTType != _prevTType && _curTType != int.MaxValue)
                if (_curTType != _prevTType)
                {
                    if (_activeInSource != null)
                    {
                        _activeInSource.Uninitialize();
                        //_activeInSource.Car = null;
                        _activeInSource = _inSources[_curTType];
                        //_activeInSource.Car = Car;
                    }

                    if (_activeOutSource != null)
                    {
                        _activeOutSource.Uninitialize();
                        //_activeOutSource.Car = null;
                        _activeOutSource = _outSources[_curTType];
                        //_activeOutSource.Car = Car;
                    }
#if DEBUGSCR
                    Trace.TraceInformation("Sound region changed from {0} to {1}.", _prevTType, _curTType);
#endif
//                    if (!stateChange) Trace.TraceInformation("StandardChange Time {4} TrainName {5} carNo {0} IsOnSwitch {1} TracksoundType {2} _CurTType {3} _PrevTType {6}",
//                        Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, _prevTType);
//                           Trace.TraceInformation("Train {0} Speed {1}, Car {2}: Sound Region {3} changed to {4} at distance {5}", Car.Train.Number, Car.Train.SpeedMpS, CarNo, _prevTType, _curTType, Math.Sqrt(trackSoundDistSquared));
                    if (CarNo == CarLeading)
                        Car.TrackSoundLocation = Car.WorldPosition.WorldLocation;
                    _prevTType = _curTType;
                }
            }
        }

        public override bool Update()
        {
            bool stateChange = false;
            if (SharedSMSFileManager.AutoTrackSound) stateChange = UpdateCarOnSwitchAndCurve();
//            if (stateChange) Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} Radius {7} Before",
//                Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve, Car.CurrentCurveRadius);
            if ((!CarOnSwitch && !CarOnCurve) || !SharedSMSFileManager.AutoTrackSound)
                UpdateTType(stateChange);
//            if (stateChange) Trace.TraceInformation("Time {4} TrainName {5} carNo {0} IsOnSwitch {1} IsOnCurve {6} TracksoundType {2} _CurTType {3} Radius {7} After",
//                Car.Train.Cars.IndexOf(Car), CarOnSwitch, Car.TrackSoundType, _curTType, Viewer.Simulator.GameTime, Car.Train.Name, CarOnCurve, Car.CurrentCurveRadius);
            bool retval = true;
            NeedsFrequentUpdate = false;

            if (_activeInSource != null)
            {
                retval &= _activeInSource.Update();
                NeedsFrequentUpdate |= _activeInSource.NeedsFrequentUpdate;
            }

            if (_activeOutSource != null)
            {
                retval &= _activeOutSource.Update();
                NeedsFrequentUpdate |= _activeOutSource.NeedsFrequentUpdate;
            }

            return retval;
        }

        public override void Dispose()
        {
            if (_inSources != null)
            {
                foreach (SoundSource s in _inSources)
                    s.Dispose();
                _inSources.Clear();
            }
            if (_outSources != null)
            {
                foreach (SoundSource s in _outSources)
                    s.Dispose();
                _outSources.Clear();
            }
            Car = null;
        }

        //Checks whether car on switch or on curve or both and selects related .sms file;
        // returns true if state has changed

        public bool UpdateCarOnSwitchAndCurve()
        {
            var stateChange = false;
            if (Car != null && Car.Train != null)
            {
                if (Car.Train.SpeedMpS > 0.1f || Car.Train.SpeedMpS < -0.1f)
                {
                    var CarNo = Car.Train.Cars.IndexOf(Car);
                    var CarIncr = 0;
                    if (Car.Train.SpeedMpS > 0.1f && CarNo != Car.Train.Cars.Count - 1) CarIncr = 1;
                    if (Car.Train.SpeedMpS < 0.1f && CarNo != 0) CarIncr = -1;

                    var CarBehind = Car.Train.Cars[CarNo + CarIncr];
                    var carPreviouslyOnSwitch = CarOnSwitch;
                    CarOnSwitch = false;
                    if (Car.Train.PresentPosition[Direction.Forward].TrackCircuitSectionIndex != Car.Train.PresentPosition[Direction.Backward].TrackCircuitSectionIndex)
                    {
                        var copyOccupiedTrack = Car.Train.OccupiedTrack.ToArray();
                        foreach (var thisSection in copyOccupiedTrack)
                        {
                            try
                            {
                                if (thisSection.CircuitType == TrackCircuitType.Junction || thisSection.CircuitType == TrackCircuitType.Crossover)
                                {
                                    // train is on a switch; let's see if car is on a switch too
                                    WorldLocation switchLocation = Viewer.Simulator.TrackDatabase.TrackDB.TrackNodes[thisSection.OriginalIndex].UiD.Location;
                                    var distanceFromSwitch = WorldLocation.GetDistanceSquared(Car.WorldPosition.WorldLocation, switchLocation);
                                    if (distanceFromSwitch < Car.CarLengthM * Car.CarLengthM + Math.Min(Car.SpeedMpS * 3, 150))
                                    {
                                          CarOnSwitch = true;
                                        break;
                                    }
                                }
                            }
                            catch { }
                        }
                    }
                    // here check for curve
                    var carPreviouslyOnCurve = CarOnCurve;
                    CarOnCurve = false;
                    if ((Car.CurrentCurveRadius > 0 && (Car.CurrentCurveRadius < 301
                         || (Car.CurrentCurveRadius < 350 && Car.WagonType == TrainCar.WagonTypes.Freight))) ||
                        (CarBehind.CurrentCurveRadius > 0 && (CarBehind.CurrentCurveRadius < 301
                         || (CarBehind.CurrentCurveRadius < 350 && Car.WagonType == TrainCar.WagonTypes.Freight))))
                    {
                        CarOnCurve = true;
                    }

                    // resume results and select sound if change
                    if (carPreviouslyOnSwitch ^ CarOnSwitch || carPreviouslyOnCurve ^ CarOnCurve)
                    { 
                        stateChange = true;
                    }
                    if (stateChange && (CarOnSwitch || CarOnCurve))
                    {
                        Car.TrackSoundLocation = Car.WorldPosition.WorldLocation;
                        if (CarOnSwitch && CarOnCurve && SharedSMSFileManager.CurveSwitchSmsNumber != -1)
                        {
                            _curTType = SharedSMSFileManager.CurveSwitchSmsNumber;
                        }
                        else if (CarOnCurve && SharedSMSFileManager.CurveSmsNumber != -1)
                        {
                            _curTType = SharedSMSFileManager.CurveSmsNumber;
                        }
                        else if (CarOnSwitch && SharedSMSFileManager.SwitchSmsNumber != -1)
                        // car on switch
                        {
                            _curTType = SharedSMSFileManager.SwitchSmsNumber;
                        }
                        else stateChange = false;
                    }
                }
                else
                    return stateChange;

                //if (_curTType != _prevTType && _curTType != int.MaxValue)
                if (_curTType != _prevTType)
                {
                    if (_activeInSource != null)
                    {
                        _activeInSource.Uninitialize();
                        //_activeInSource.Car = null;
                        _activeInSource = _inSources[_curTType];
                        //_activeInSource.Car = Car;
                    }

                    if (_activeOutSource != null)
                    {
                        _activeOutSource.Uninitialize();
                        //_activeOutSource.Car = null;
                        _activeOutSource = _outSources[_curTType];
                        //_activeOutSource.Car = Car;
                    }
#if DEBUGSCR
                    Trace.TraceInformation("Sound region changed from {0} to {1}.", _prevTType, _curTType);
#endif

                    //Trace.TraceInformation("Train {0} Speed {1}, Car {2}: Sound Region {3} changed to {4} at distance {5}", Car.Train.Number, Car.Train.SpeedMpS, CarNo, _prevTType, _curTType, Math.Sqrt(trackSoundDistSquared));
                    _prevTType = _curTType;
                }
            }
            return stateChange;
        }
    }
    
    /// <summary>
    /// Represents an sms file
    /// </summary>
    public class SoundSource : SoundSourceBase
    {
        /// <summary>
        /// Squeared cutoff distance. No sound is audible above that
        /// </summary>
        private const int CUTOFFDISTANCE = 4000000;
        /// <summary>
        /// Max distance for OpenAL inverse distance model. Equals to Math.Sqrt(CUTOFFDISTANCE)
        /// </summary>
        public const float MaxDistanceM = 2000f;
        /// <summary>
        /// Desired max gain at max distance for OpenAL inverse distance model
        /// </summary>
        public const float GainAtMaxDistance = 0.025f;
        /// <summary>
        /// Below this distance there is no attenuation. Used by OpenAL inverse distance model
        /// </summary>
        public const float ReferenceDistanceM = 8f;
        /// <summary>
        /// Sound attenuation factor. Calculated to achieve goal set by <see cref="GainAtMaxDistance"/>
        /// </summary>
        public float RolloffFactor;
        /// <summary>
        /// Used for InGame sounds and activity sounds of type "Overall"
        /// </summary>
        public bool IsUnattenuated;
        /// <summary>
        /// Used for Horns
        /// </summary>
        public float HornRolloffFactor = 0.05f;

        /// <summary>
        /// Construct a SoundSource attached to a train car.
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, MSTSWagon car, string smsFilePath)
        {
            Car = car;
            Initialize(viewer, car.WorldPosition.WorldLocation, SoundEventSource.Car, smsFilePath);
        }

        /// <summary>
        /// Initializes a SoundSource which has no specific location - like ingame.sms
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, SoundEventSource eventSource, string smsFilePath, bool isUnattenuated)
        {
            IsUnattenuated = isUnattenuated;
            Initialize(viewer, WorldLocation.None, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath)
        {
            IsEnvSound = true;
            Initialize(viewer, worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(Viewer viewer, in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath, bool slowRolloff)
        {
            IsEnvSound = true;
            SlowRolloff = slowRolloff;
            Initialize(viewer, worldLocation, eventSource, smsFilePath);
        }

        /// <summary>
        /// Construct a SoundSource attached to a train car, with predefined parameters (activity sound).
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="car"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, MSTSWagon car, string wavFilePath, OrtsActivitySoundFileType ORTSActSoundFileType,  bool preCompiled)
        {
            Car = car;
            Initialize(viewer, car.WorldPosition.WorldLocation, SoundEventSource.Car, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource which has no specific location - like ingame.sms, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        public SoundSource(Viewer viewer, SoundEventSource eventSource, string wavFilePath, OrtsActivitySoundFileType ORTSActSoundFileType, bool isUnattenuated, bool preCompiled)
        {
            IsUnattenuated = isUnattenuated;
            Initialize(viewer, WorldLocation.None, eventSource, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource stationary at the specified worldLocation, with predefined parameters (activity sound)
        /// </summary>
        /// <param name="viewer"></param>
        /// <param name="worldLocation"></param>
        /// <param name="eventSource"></param>
        /// <param name="smsFilePath"></param>
        /// <param name="slowRolloff"></param>
        public SoundSource(Viewer viewer, in WorldLocation worldLocation, SoundEventSource eventSource, string wavFilePath, bool slowRolloff, OrtsActivitySoundFileType ORTSActSoundFileType, bool preCompiled)
        {
            IsEnvSound = true;
            SlowRolloff = slowRolloff;
            Initialize(viewer, worldLocation, eventSource, wavFilePath, ORTSActSoundFileType, preCompiled);
        }

        /// <summary>
        /// Construct a SoundSource that has no specific location and a set of programmatically defined <see cref="SoundStream"/>s.
        /// </summary>
        /// <param name="viewer">The <see cref="Viewer"/> to attach this SoundSource to.</param>
        /// <param name="makeStreams">A generator function to create the attached SoundStreams.</param>
        public SoundSource(Viewer viewer, Func<SoundSource, IEnumerable<SoundStream>> makeStreams)
        {
            IsUnattenuated = true;
            Initialize(viewer);
            SoundStreams.AddRange(makeStreams(this));
        }

        /// <summary>
        /// Stop the streams, free up OpenAL sound source IDs and try to unload wave data from memory
        /// </summary>
        public override void Uninitialize()
        {
            foreach (SoundStream ss in SoundStreams)
            {
                ss.Stop();
                ss.HardDeactivate();
                WasOutOfDistance = true;
                NeedsFrequentUpdate = false;
            }
        }
        
        /// <summary>
        /// Current location of the sound source
        /// </summary>
        public WorldLocation WorldLocation;

        /// <summary>
        /// The wave files will be relative to this folder
        /// </summary>
        public string SMSFolder;
        public string SMSFileName;
        public string WavFolder;
        public string WavFileName;
        public bool Active;
        private SoundActivationCondition ActivationConditions;
        private SoundActivationCondition DeactivationConditions;
        public bool IsEnvSound;
        public bool IsExternal = true;
        public bool Ignore3D;
        /// <summary>
        /// MSTS treats Stereo() tagged mono wav files specially. This is a flag
        /// indicating if this treatment should be applied here
        /// </summary>
        public bool MstsMonoTreatment;

        /// <summary>
        /// Current distance to camera, squared meter. Is used for comparision to <see cref="CUTOFFDISTANCE"/>, to determine if is out-of-scope
        /// </summary>
        public float DistanceSquared = CUTOFFDISTANCE + 1;
        /// <summary>
        /// Out-of-scope state in previous <see cref="Update"/> loop
        /// </summary>
        private bool WasOutOfDistance = true;
        /// <summary>
        /// Different rolloff factor is used for track sounds not to attenuate so fast. As a bargain they are not silenced at cutoff distance
        /// </summary>
        private bool SlowRolloff;

        /// <summary>
        /// List of Streams in sms
        /// </summary>
        public List<SoundStream> SoundStreams = new List<SoundStream>();

        /// <summary>
        /// Set properties of this SoundSource based on parsing the sms file, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sms belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(Viewer viewer, in WorldLocation worldLocation, SoundEventSource eventSource, string smsFilePath)
        {
            Viewer = viewer;
            WorldLocation = worldLocation;

            if (smsFilePath == null)
                return;

            SMSFolder = Path.GetDirectoryName(smsFilePath);
            SMSFileName = Path.GetFileName(smsFilePath);
            SoundManagmentFile smsFile = SharedSMSFileManager.Get(smsFilePath);


            // find correct ScalabiltyGroup
            int iSG = 0;
            while ( iSG < smsFile.ScalabiltyGroups.Count)
            {
                if (smsFile.ScalabiltyGroups[iSG].DetailLevel <= Viewer.Settings.SoundDetailLevel)
                    break;
                ++iSG;
            }
            if (iSG < smsFile.ScalabiltyGroups.Count && smsFile.ScalabiltyGroups[iSG].Streams != null)  // else we want less sound so don't provide any
            {
                ScalabilityGroup mstsScalabiltyGroup = smsFile.ScalabiltyGroups[iSG];

                ActivationConditions = mstsScalabiltyGroup.Activation;
                DeactivationConditions = mstsScalabiltyGroup.Deactivation;
                Volume = mstsScalabiltyGroup.Volume;
                Ignore3D = mstsScalabiltyGroup.Ignore3D | mstsScalabiltyGroup.Stereo;
                MstsMonoTreatment = mstsScalabiltyGroup.Stereo;
                IsExternal = ActivationConditions.ExternalCam;

                SetRolloffFactor();

                foreach (SmsStream mstsStream in mstsScalabiltyGroup.Streams)
                {
                    SoundStreams.Add(new SoundStream(mstsStream, eventSource, this, Viewer.Settings));
                }
            }
        }

                /// <summary>
        /// Set properties of this SoundSource with default precompiled parameters, and generate SoundStreams
        /// </summary>
        /// <param name="viewer">Current <see cref="Viewer3D"/></param>
        /// <param name="worldLocation">World location of <see cref="SoundSource"/></param>
        /// <param name="eventSource">Type of game part sound source belongs to, to determine how to interpret discrete trigger numbers</param>
        /// <param name="smsFilePath">Full path for sms file</param>
        public void Initialize(Viewer viewer, in WorldLocation worldLocation, SoundEventSource eventSource, string wavFilePath, OrtsActivitySoundFileType ORTSActSoundFileType, bool preCompiled)
        {
            Viewer = viewer;
            WorldLocation = worldLocation;

            if (wavFilePath == null)
                return;

            WavFolder = Path.GetDirectoryName(wavFilePath);
            WavFileName = Path.GetFileName(wavFilePath);
            SMSFolder = WavFolder;
            SMSFileName = WavFileName;

            if (Viewer.Settings.SoundDetailLevel >= 3)
            {
                // base initializations
                ActivationConditions = new SoundActivationCondition(ORTSActSoundFileType, ActivationType.Activate);
                DeactivationConditions = new SoundActivationCondition(ORTSActSoundFileType, ActivationType.Deactivate);
                switch (ORTSActSoundFileType)
                {
                    case OrtsActivitySoundFileType.Everywhere:
                        Ignore3D = true;
                        IsExternal = true;
                        break;
                    default:
                    case OrtsActivitySoundFileType.Cab:
                    case OrtsActivitySoundFileType.Pass:
                        Ignore3D = true;
                        IsExternal = false;
                        break;
                    case OrtsActivitySoundFileType.Ground:
                    case OrtsActivitySoundFileType.Location:
                        Ignore3D = false;
                        IsExternal = true;
                        break;
                }
                Volume = 1.0f;
                SetRolloffFactor();

                // initialization of the only one sound stream
                SoundStreams.Add(new SoundStream(WavFileName, eventSource, this)); 
            }
        }

        private void Initialize(Viewer viewer)
        {
            Viewer = viewer;
            WorldLocation = WorldLocation.None;

            ActivationConditions = new SoundActivationCondition(OrtsActivitySoundFileType.Everywhere, ActivationType.Activate);
            DeactivationConditions = new SoundActivationCondition(OrtsActivitySoundFileType.Everywhere, ActivationType.Deactivate);

            Volume = 1.0f;
            SetRolloffFactor();
        }

        private void SetRolloffFactor()
        {
            var deactivationDistance = DeactivationConditions != null && DeactivationConditions.Distance != 0 ? DeactivationConditions.Distance : MaxDistanceM;
            var maxDistanceM = Math.Min(MaxDistanceM, deactivationDistance);

            // OpenAL inverse distance model is based on formula
            // Gain = AL_REFERENCE_DISTANCE / ( AL_REFERENCE_DISTANCE + AL_ROLLOFF_FACTOR * ( Distance - AL_REFERENCE_DISTANCE ) )
            RolloffFactor = SlowRolloff ? 0.4f : ReferenceDistanceM * (1f / GainAtMaxDistance - 1f) / (maxDistanceM - ReferenceDistanceM);
        }

        /// <summary>
        /// Check if an event needs action from one of discrete triggers
        /// </summary>
        /// <param name="eventID">Occured event</param>
        public void HandleEvent(TrainEvent eventID)
        {
            foreach (var ss in SoundStreams)
            {
                foreach (var trg in ss.Triggers)
                {
                    var dt = trg as ORTSDiscreteTrigger;
                    if (dt != null)
                        dt.HandleEvent(eventID);
                }
            }
        }

        public override void InitInitials()
        {
            if (Car != null)
            {
                WorldLocation = Car.WorldPosition.WorldLocation;
            }

            if (isOutOfDistance())
            {
                if (!WasOutOfDistance)
                {
                    if (!Viewer.Simulator.updaterWorking)
                    {
                        foreach (SoundStream stream in SoundStreams)
                            stream.HardDeactivate();
                        WasOutOfDistance = true;
                    }
                }
                NeedsFrequentUpdate = false;
            }
            else
            {
                if (WasOutOfDistance)
                {
                    var ignore3D = WorldLocation == WorldLocation.None | Ignore3D | !IsExternal;
                    foreach (SoundStream stream in SoundStreams)
                    {
                        stream.HardActivate(ignore3D);

                        bool released = false;
                        // run the initial triggers
                        foreach (ORTSTrigger trigger in stream.Triggers)
                        {
                            trigger.Initialize();
                            trigger.TryTrigger();

                            released |= trigger.Signaled &&
                                (trigger.SoundCommand is ORTSReleaseLoopRelease || trigger.SoundCommand is ORTSReleaseLoopReleaseWithJump);
                            if (trigger is ORTSDiscreteTrigger) trigger.Signaled = false;
                        }

                        if (!released && !stream.ALSoundSource.isPlaying)
                        {
                            foreach (ORTSTrigger trigger in stream.Triggers)
                            {
                                if (trigger.Signaled && trigger.Enabled && (trigger.SoundCommand is ORTSStartLoop || trigger.SoundCommand is ORTSStartLoopRelease))
                                    trigger.SoundCommand.Run();
                            }
                        }
                    }
                }
                WasOutOfDistance = false;
            }
        }
        
        public override bool Update()
        {
            if (Car != null && !Car.IsPartOfActiveTrain)
                return false;

            InitInitials();

            if (WasOutOfDistance)
            {
                // It is still needed to try out-of-distance variable triggers, to handle their start and release events, so they will be in
                // correct state when get into scope again. Discrete triggers have their HandleEvent() function to achieve this,
                // but there is no such thing for variable triggers.
                foreach (var stream in SoundStreams)
                    foreach (var trigger in stream.VariableTriggers)
                        trigger.TryTrigger();

                return true;
            }

            if (!Active)
            {
                if (Activate())
                {
                    Active = true;

                    // restore any looping sounds
                    foreach(SoundStream stream in SoundStreams)
                        stream.Activate();
                }
            }
            else
            {
                if (DeActivate())
                {
                    foreach (SoundStream stream in SoundStreams)
                        stream.Deactivate();

                    Active = false;
                }
            }

            bool needsFrequentUpdate = false;

            if (Car == null && WorldLocation != WorldLocation.None && !Ignore3D && IsExternal)
            {
                WorldLocation = WorldLocation.NormalizeTo(Camera.SoundBaseTile.X, Camera.SoundBaseTile.Y);
                float[] position = new float[] {
                    WorldLocation.Location.X,
                    WorldLocation.Location.Y,
                    WorldLocation.Location.Z};

                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update(position);
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            else
            {
                foreach (SoundStream stream in SoundStreams)
                {
                    stream.Update();
                    needsFrequentUpdate |= stream.NeedsFrequentUpdate;
                }
            }
            NeedsFrequentUpdate = needsFrequentUpdate;

            return true;
        } // Update

        /// <summary>
        /// Calculate current distance to camera, and compare it to <see cref="CUTOFFDISTANCE"/>
        /// </summary>
        /// <returns>True, if is now out-of-scope</returns>
        public bool isOutOfDistance()
        {
            if (WorldLocation == WorldLocation.None)
            {
                DistanceSquared = 0;
                return false;
            }

            if (float.IsNaN(WorldLocation.Location.X) ||
                float.IsNaN(WorldLocation.Location.Y) ||
                float.IsNaN(WorldLocation.Location.Z))
            {
                DistanceSquared = CUTOFFDISTANCE + 1;
                return true;
            }

            DistanceSquared = (float)WorldLocation.GetDistanceSquared(WorldLocation, Viewer.Camera.CameraWorldLocation);

            return DistanceSquared > CUTOFFDISTANCE;
        }

        /// <summary>
        /// Check if activation conditions are met,
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool Activate()
        {
            if (ActivationConditions == null)
                return false;

            if (ConditionsMet(ActivationConditions))
            {
                if (WorldLocation != WorldLocation.None)
                {
                    // (ActivationConditions.Distance == 0) means distance checking disabled
                    if ((ActivationConditions.Distance == 0 || DistanceSquared < ActivationConditions.Distance * ActivationConditions.Distance) &&
                        DistanceSquared < CUTOFFDISTANCE)
                        return true;
                }
                else
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Check if deactivation conditions are met
        /// ie PassengerCam, CabCam, Distance etc
        /// </summary>
        /// <returns>True, if conditions were met</returns>
        public bool DeActivate()
        {
            if (DeactivationConditions == null)
                return false;
         
            if (ConditionsMet(DeactivationConditions))
                return true;

            if (WorldLocation != WorldLocation.None)
            {
                if (DeactivationConditions.Distance != 0 && DistanceSquared > DeactivationConditions.Distance * DeactivationConditions.Distance ||
                    DistanceSquared > CUTOFFDISTANCE)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if SoundSource belongs to a cabview of a vehicle not currently watched. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool IsntThisCabView
        {
            get
            {
                return (Viewer.Camera.Style == Camera.Styles.Cab || Viewer.Camera.Style == Camera.Styles.ThreeDimCab || Viewer.Camera.Style == Camera.Styles.Passenger) && (Viewer.Camera.AttachedCar != Car);
            }
        }

        /// <summary>
        /// Returns true if SoundSource is a weather sound. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        private bool WeatherSound { get { return Viewer.World.WeatherControl.WeatherSounds.Contains(this); } }

        /// <summary>
        /// Hack for enabling additional cab sounds (like radio sounds) of an attached (maybe invisible) car. Used at <see cref="ConditionsMet"/> check
        /// </summary>
        /// <returns></returns>
        private bool IsInvisibleSoundCar
        {
            get
            {
                return (!IsEnvSound && !IsExternal && (Viewer.Camera.Style == Camera.Styles.Cab || Viewer.Camera.Style == Camera.Styles.ThreeDimCab)
                    && Car != null && Viewer.Camera.AttachedCar != null && !(Car is MSTSLocomotive) && !Car.HasInsideView && Car.PassengerViewpoints.Count == 0
                    && (Car.Train == Viewer.Camera.AttachedCar.Train || Car.Train.TrainType == TrainType.Static || Car.Train.TrainType == TrainType.AiNotStarted));
            }
        }

        /// <summary>
        /// Return true of the ViewPoint matches any of the ones specified in the conditions
        /// for activation or deactivation.
        /// </summary>
        /// <param name="conditions"></param>
        /// <returns></returns>
        private bool ConditionsMet(SoundActivationCondition conditions)
        {
            if (conditions == null)
                return false;

            Camera.Styles viewpoint = Viewer.Camera.Style;

            if (IsEnvSound || !IsEnvSound && IsntThisCabView && !IsInvisibleSoundCar && !WeatherSound)
            {
                viewpoint = Camera.Styles.External;
            }

            if (conditions.CabCam && (viewpoint == Camera.Styles.Cab || viewpoint == Camera.Styles.ThreeDimCab))
                return true;
            if (conditions.PassengerCam && viewpoint == Camera.Styles.Passenger)
                return true;
            if (conditions.ExternalCam && viewpoint == Camera.Styles.External)
                return true;

            return false;
        }

        public override void Dispose()
        {
            if (SoundStreams != null)
            {
                foreach (SoundStream s in SoundStreams)
                    s.Dispose();
                SoundStreams.Clear();
            }
            Car = null;
        }
    }

/////////////////////////////////////////////////////////
// SOUND STREAM
/////////////////////////////////////////////////////////
        
    /// <summary>
    /// Owned by a <see cref="SoundSource"/>,
    /// can play only one sound at a time,
    /// the sound played is controlled by the various triggers
    /// </summary>
    public class SoundStream : IDisposable
    {
        /// <summary>
        /// Owner SoundSource
        /// </summary>
        public SoundSource SoundSource;
        /// <summary>
        /// Stream's volume can be controlled independently of the SoundSource's
        /// </summary>
        public float Volume;
        /// <summary>
        /// List of triggers controlling this stream
        /// </summary>
        public List<ORTSTrigger> Triggers = new List<ORTSTrigger>();
        /// <summary>
        /// OpenAL compatible representation of SoundStream.
        /// By OpenAL terminilogy our SoundStream is called as "SoundSource"
        /// </summary>
        public ALSoundSource ALSoundSource { get; private set; }
        /// <summary>
        /// A stream as is represented in sms file
        /// </summary>
        protected SmsStream MSTSStream;
        /// <summary>
        /// Each stream can contain only one initial trigger, which should be audible
        /// in case the SoundSource is in scope, and no other variable trigger is active
        /// </summary>
        private ORTSInitialTrigger _InitialTrigger;
        /// <summary>
        /// If soundstream needs active management by sound process, or can be left to OpenAL
        /// </summary>
        public bool NeedsFrequentUpdate;
        /// <summary>
        /// If stream contains a release trigger with jump, looping cannot be handled fully by OpenAL.
        /// Sound process needs to watch carefully for jump command
        /// </summary>
        public bool IsReleasedWithJump;
        /// <summary>
        /// Store trigger used last time for being able to check if trigger got repeated
        /// </summary>
        public ORTSTrigger LastTriggered = new ORTSTrigger();
        /// <summary>
        /// True if the same trigger was used repeatedly.
        /// Needs for avoiding to queue same sound multiple times
        /// in case the player keeps hitting the keyboard
        /// </summary>
        public bool RepeatedTrigger;
        /// <summary>
        /// List of owned variable triggers. Used at determining if initial trigger is to be audible
        /// </summary>
        public List<ORTSTrigger> VariableTriggers = new List<ORTSTrigger>();

        /// <summary>
        /// Helper object for determining if initial trigger is to be audible
        /// </summary>
        private IEnumerable<ORTSTrigger> TriggersList;

        public SoundStream(SmsStream mstsStream, SoundEventSource eventSource, SoundSource soundSource, UserSettings settings)
        {
            SoundSource = soundSource;
            MSTSStream = mstsStream;
            Volume = MSTSStream.Volume;
            var rolloffFactor = SoundSource.RolloffFactor;

            // Insert lower RollOff for horns
            if (mstsStream.Triggers != null)
            {
                foreach (Trigger trigger in mstsStream.Triggers)
                    if (trigger is DiscreteTrigger && soundSource.Car != null && (trigger as DiscreteTrigger).TriggerId == 8)
                    {
                        rolloffFactor = SoundSource.HornRolloffFactor;
                        break;
                    }
            }

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, rolloffFactor);

            if (mstsStream.Triggers != null)
                foreach (Trigger trigger in mstsStream.Triggers)
                {
                    if (trigger.SoundCommand == null) // ignore improperly formed SMS files
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                    }
                    else if (trigger is DistanceTravelledTrigger && soundSource.Car != null)
                    {
                        Triggers.Add(new ORTSDistanceTravelledTrigger(this, (DistanceTravelledTrigger)trigger));
                    }
                    else if (trigger is InitialTrigger)
                    {
                        _InitialTrigger = new ORTSInitialTrigger(this, (InitialTrigger)trigger);
                        Triggers.Add(_InitialTrigger);
                    }
                    else if (trigger is RandomTrigger)
                    {
                        Triggers.Add(new ORTSRandomTrigger(this, (RandomTrigger)trigger));
                    }
                    else if (trigger is VariableTrigger && (soundSource.Car != null || soundSource.IsEnvSound))
                    {
                        Triggers.Add(new ORTSVariableTrigger(this, (VariableTrigger)trigger));
                    }
                    else if (trigger is DiscreteTrigger && soundSource.Car != null)
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, eventSource, (DiscreteTrigger)trigger, settings);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable
                        try
                        {
                            SoundSource.Car.EventHandlers.Add(ortsTrigger);  // tell the simulator to call us when the event occurs
                        }
                        catch (Exception error)
                        {
                            Trace.TraceInformation("Sound event skipped due to thread safety problem" + error.Message);
                        }
                    }
                    else if (trigger is DiscreteTrigger)
                    {
                        ORTSDiscreteTrigger ortsTrigger = new ORTSDiscreteTrigger(this, eventSource, (DiscreteTrigger)trigger, settings);
                        Triggers.Add(ortsTrigger);  // list them here so we can enable and disable 
                    }
                        // unapplicable trigger type
                    else
                    {
                        Triggers.Add(new ORTSTrigger()); // null trigger
                        if (SoundSource.SMSFileName != "ingame.sms") Trace.TraceWarning("Trigger type of trigger number {2} in stream number {1} in file {0} is not existent or not applicable",
                            SoundSource.SMSFileName, SoundSource.SoundStreams.Count, Triggers.Count-1);
                    }
                    IsReleasedWithJump |= (Triggers.Last().SoundCommand is ORTSReleaseLoopReleaseWithJump);
                }  // for each mstsStream.Trigger

            VariableTriggers = (from t in Triggers 
                                where t is ORTSVariableTrigger
                                select t).ToList();
        }

        public SoundStream(string wavFileName, SoundEventSource eventSource, SoundSource soundSource)
        {
            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);

            _InitialTrigger = new ORTSInitialTrigger(this, wavFileName);
            Triggers.Add(_InitialTrigger);

        }

        /// <summary>
        /// Create a sound stream with an arbitrary set of triggers.
        /// </summary>
        /// <param name="soundSource">The parent sound source.</param>
        /// <param name="makeTriggers">A generator function to create the triggers.</param>
        public SoundStream(SoundSource soundSource, Func<SoundStream, IEnumerable<ORTSTrigger>> makeTriggers)
        {
            SoundSource = soundSource;
            Volume = 1.0f;

            ALSoundSource = new ALSoundSource(soundSource.IsEnvSound, soundSource.RolloffFactor);
            Triggers.AddRange(makeTriggers(this));
        }

        /// <summary>
        /// Update OpenAL sound source position, then calls the main <see cref="Update()"/> function
        /// Position is relative to camera tile's center
        /// </summary>
        /// <param name="position"></param>
        public void Update(float[] position)
        {
            OpenAL.alSourcefv(ALSoundSource.SoundSourceID, OpenAL.AL_POSITION, position);
            Update();
        }

        /// <summary>
        /// Try triggers, update frequency and volume according to curves, call queue management
        /// </summary>
        public void Update()
        {
            if (ALSoundSource == null)
            {
                return;
            }

            foreach (ORTSTrigger trigger in Triggers)
                trigger.TryTrigger();
            
            if (_InitialTrigger != null)
            {
                // If no triggers active, Initialize the Initial
                if (!ALSoundSource.isPlaying)
                {
                    if (VariableTriggers.Count > 0 || Triggers.Count == 1)
                    {
                        TriggersList = from ORTSVariableTrigger t in VariableTriggers
                                                where t.IsBellow
                                                select t as ORTSTrigger;
                        if (TriggersList.Count() == VariableTriggers.Count && _InitialTrigger.SoundCommand is ORTSSoundPlayCommand
                            && !(_InitialTrigger.SoundCommand is ORTSPlayOneShot && _InitialTrigger.Signaled))
                        {
                            _InitialTrigger.Initialize();
                        }
                    }
                }
                // If triggers are active, reset the Initial
                else
                {
                    TriggersList = from t in Triggers
                             where t.Signaled &&
                             (t.SoundCommand is ORTSStartLoop || t.SoundCommand is ORTSStartLoopRelease)
                             select t;
                    if (TriggersList.Count() > 1 && _InitialTrigger.Signaled)
                        _InitialTrigger.Signaled = false;
                }
            }

            SetFreqAndVolume();

            ALSoundSource.Update();
            NeedsFrequentUpdate |= ALSoundSource.NeedsFrequentUpdate;
        }

        /// <summary>
        /// Calculate frequency and volume according to curves defined in sms file
        /// </summary>
        private void SetFreqAndVolume()
        {
            if (ALSoundSource == null)
                return;

            if (MSTSStream != null && MSTSStream.FrequencyCurve != null) 
            {
                if (SoundSource.Car != null || SoundSource.Viewer.Camera.AttachedCar != null)
                {
                    float x = 0;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Mode, SoundSource.Car);
                    else if (SoundSource.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.FrequencyCurve.Mode, (MSTSWagon)SoundSource.Viewer.Camera.AttachedCar);
                    float y = Interpolate(x, MSTSStream.FrequencyCurve);
                    if (SoundSource.MstsMonoTreatment && ALSoundSource.MstsMonoTreatment)
                        y *= 2;

                    ALSoundSource.PlaybackSpeed = y / ALSoundSource.SampleRate;
                    NeedsFrequentUpdate = x != 0;
                }
            }

            float volume = SoundSource.Volume * Volume;

            if (MSTSStream != null && MSTSStream.VolumeCurves.Count > 0)
                for (int i = 0; i < MSTSStream.VolumeCurves.Count; i++)
                {
                    float x;
                    if (SoundSource.Car != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Mode, SoundSource.Car);
                    else if (SoundSource.Viewer.Camera.AttachedCar != null)
                        x = ReadValue(MSTSStream.VolumeCurves[i].Mode, (MSTSWagon)SoundSource.Viewer.Camera.AttachedCar);
                    else
                        x = SoundSource.DistanceSquared;

                    volume *= Interpolate(x, MSTSStream.VolumeCurves[i]);
                }

            if (SoundSource.IsExternal && SoundSource.Viewer.Camera.Style != Camera.Styles.External && !SoundSource.IsUnattenuated)
            {
                if (SoundSource.Viewer.Camera.AttachedCar == null || ((MSTSWagon)SoundSource.Viewer.Camera.AttachedCar).ExternalSoundPassThruPercent == -1)
                    volume *= Program.Viewer.Settings.ExternalSoundPassThruPercent * 0.01f;
                else volume *= ((MSTSWagon)SoundSource.Viewer.Camera.AttachedCar).ExternalSoundPassThruPercent * 0.01f;
            }

            ALSoundSource.Volume = volume;
        }

        /// <summary>
        /// There must be at least two points in the curve
        /// // TODO do we need to implement support for Granularity()
        /// </summary>
        /// <param name="x"></param>
        /// <param name="Curve"></param>
        /// <returns></returns>
        private static float Interpolate(float x, Curve Curve)
        {
            if (Curve.CurvePoints.Length < 2)
                return Curve.CurvePoints[0].Y;

            CurvePoint[] curvePoints = Curve.CurvePoints;

            if (x < curvePoints[0].X)
                return curvePoints[0].Y;
            if (x > curvePoints[curvePoints.Length - 1].X)
                return curvePoints[curvePoints.Length - 1].Y;

            int i = 1;
            while (i < curvePoints.Length - 1
                && curvePoints[i].X < x) ++i;
            // i points to the point equal to or above x, or to the last point in the table

            x -= curvePoints[i - 1].X;
            float rx = x / (curvePoints[i].X - curvePoints[i - 1].X);

            float dy = curvePoints[i].Y - curvePoints[i - 1].Y;

            float y = curvePoints[i - 1].Y + rx * dy;

            return y;
        }

        /// <summary>
        /// Read a variable from the attached TrainCar data
        /// </summary>
        /// <param name="control"></param>
        /// <param name="car"></param>
        /// <returns></returns>
        private float ReadValue(Curve.ControlMode control, MSTSWagon car)
        {
            switch (control)
            {
                case Curve.ControlMode.Distance: return SoundSource.DistanceSquared;
                case Curve.ControlMode.Speed: return car.AbsSpeedMpS;
                case Curve.ControlMode.Variable1: return car.Variable1;
                case Curve.ControlMode.Variable2: return car.Variable2;
                case Curve.ControlMode.Variable3: return car.Variable3;
                case Curve.ControlMode.BrakeCylinder: return car.BrakeSystem.GetCylPressurePSI();
                case Curve.ControlMode.CurveForce: return (float)car.CurveForceNFiltered;
                default: return 0;
            }
        }

        /// <summary>
        /// Stop OpenAL playing this stream, and flush buffers
        /// </summary>
        public void Stop()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Stop();
            }
        }

        /// <summary>
        /// Restore any previously playing sounds
        /// </summary>
        public void Activate()
        {
            if (ALSoundSource != null)
            {
                // Precalc volume to avoid glitches
                SetFreqAndVolume();
                ALSoundSource.Active = true;
            }
        }

        /// <summary>
        /// Deactivates a previously active sound
        /// </summary>
        public void Deactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.Active = false;
                ALSoundSource.HardDeactivate();
            }
        }

        /// <summary>
        /// Allocates a new sound source ID in OpenAL, if one is not allocated yet.
        /// </summary>
        /// <param name="ignore3D">Whether the stream's world position should be ignored</param>
        public void HardActivate(bool ignore3D)
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardActivate(ignore3D, SoundSource.Car);
            }
        }

        /// <summary>
        /// Frees up the allocated sound source ID, and tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        public void HardDeactivate()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
            }
            Sweep();
        }

        public void Dispose()
        {
            if (ALSoundSource != null)
            {
                ALSoundSource.HardDeactivate();
                ALSoundSource.Dispose();
                ALSoundSource = null;
            }
            Sweep();
        }

        /// <summary>
        /// Tries to unload wave file data from memory, if it is not used by an other stream
        /// </summary>
        private void Sweep()
        {
            foreach (var trigger in Triggers)
                if (trigger.SoundCommand is ORTSSoundPlayCommand)
                    foreach (var name in (trigger.SoundCommand as ORTSSoundPlayCommand).Files)
                        SoundItem.Sweep(name, SoundSource.IsExternal, IsReleasedWithJump);
        }

    } // class ORTSStream

/////////////////////////////////////////////////////////
// SOUND TRIGGERS
/////////////////////////////////////////////////////////

    /// <summary>
    /// Trigger is defined in the SMS file as members of a SoundStream.
    /// They are activated by various events.
    /// When triggered, executes a SoundCommand
    /// </summary>
    public class ORTSTrigger
    {
        /// <summary>
        /// Set by the DisableTrigger, EnableTrigger sound commands
        /// </summary>
        public bool Enabled = true;
        /// <summary>
        /// True if trigger activation conditions are met
        /// </summary>
        public bool Signaled;
        /// <summary>
        /// Represents a sound command to be executed, when trigger is activated
        /// </summary>
        public ORTSSoundCommand SoundCommand;

        /// <summary>
        /// Check in every update loop whether to activate the trigger
        /// </summary>
        public virtual void TryTrigger() { }
        /// <summary>
        /// Executed in constructors, or when sound source gets into scope, or for InitialTrigger when other VariableTriggers stop working
        /// </summary>
        public virtual void Initialize() { }
    }


    /// <summary>
    /// Play this sound when a discrete TrainCar event occurs in the simulator
    /// </summary>
    public class ORTSDiscreteTrigger: ORTSTrigger, IEventHandler
    {
        /// <summary>
        /// Event this trigger listens to
        /// </summary>
        public TrainEvent TriggerID;
        /// <summary>
        /// Store the owning SoundStream
        /// </summary>
        private SoundStream SoundStream;
        /// <summary>
        /// This flag is set by Updater process, and is used by Sound process to activate the trigger
        /// </summary>
        private bool Triggered;

        public ORTSDiscreteTrigger(SoundStream soundStream, SoundEventSource eventSound, DiscreteTrigger smsData, UserSettings settings)
        {
            TriggerID = SoundEvent.From(eventSound, smsData.TriggerId);
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        /// <summary>
        /// Construct a discrete sound trigger with an arbitrary event trigger and sound command.
        /// </summary>
        /// <param name="soundStream">The parent sound stream.</param>
        /// <param name="triggerID">The trigger to activate this event.</param>
        /// <param name="soundCommand">The command to run when activated.</param>
        public ORTSDiscreteTrigger(SoundStream soundStream, TrainEvent triggerID, ORTSSoundCommand soundCommand)
        {
            TriggerID = triggerID;
            SoundCommand = soundCommand;
            SoundStream = soundStream;
        }

        /// <summary>
        /// Check if this trigger listens to an event
        /// </summary>
        /// <param name="trainEvent">Occured event</param>
        public void HandleEvent(TrainEvent trainEvent)
        {
            if (trainEvent == TriggerID)
            {
                Triggered = true;
            }
        }

        /// <summary>
        /// Check if this trigger listens to an event, and if also belongs to the object
        /// </summary>
        /// <param name="trainEvent">Occured event</param>
        /// <param name="viewer">Object the event belongs to</param>
        public void HandleEvent(TrainEvent trainEvent, object viewer)
        {
            if (trainEvent == TriggerID)
            {
                try
                {
                    if (Program.Viewer.SoundProcess.IsSoundSourceOwnedBy(viewer, SoundStream.SoundSource))
                    {
                        Triggered = true;
                    }
                }
                catch
                {
                    return;
                }
            }
        }

        public override void TryTrigger()
        {
            Triggered &= Enabled;
            if (Triggered)
            {
                Triggered = false;
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
                Signaled = true;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Trace.WriteLine("({0})DiscreteTrigger: {1}:{2}", SoundStream.ALSoundSource.SoundSourceID, TriggerID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
                else
                    Trace.WriteLine("({0})DiscreteTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, TriggerID);
#endif
            }
            // If the SoundSource is not active, should deactivate the SoundStream also
            //   preventing the hearing when not should be audible
            if (!SoundStream.SoundSource.Active)
                SoundStream.Deactivate();
        }

    } // class ORTSDiscreteTrigger

    /// <summary>
    /// Play this sound controlled by the distance a TrainCar has travelled
    /// </summary>
    public sealed class ORTSDistanceTravelledTrigger : ORTSTrigger
    {
        private DistanceTravelledTrigger SMS;
        private float triggerDistance;
        private TrainCar car;
        private SoundStream SoundStream;

        public ORTSDistanceTravelledTrigger(SoundStream soundStream, DistanceTravelledTrigger smsData)
        {
            SoundStream = soundStream;
            car = soundStream.SoundSource.Car;
            SMS = smsData;
            SoundCommand = ORTSSoundCommand.FromMSTS(SMS.SoundCommand, soundStream );
            Initialize();
        }

        public override void Initialize()
        {
            UpdateTriggerDistance();
        }

        public override void TryTrigger()
        {
            if (car.DistanceM > triggerDistance)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)Viewer.Random.NextDouble() * (SMS.MaximumVolume - SMS.MinimumVolume) + SMS.MinimumVolume;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerDistance();
#if DEBUGSCR
                Trace.WriteLine("({0})DistanceTravelledTrigger: Current:{1}, Next:{2}", SoundStream.ALSoundSource.SoundSourceID, car.DistanceM, triggerDistance);
#endif

            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate a new random distance to travel till the next trigger action
        /// </summary>
        private void UpdateTriggerDistance()
        {
            if (SMS.MaximumDistance != SMS.MinimumDistance)
            {
                triggerDistance = car.DistanceM + ((float)Viewer.Random.NextDouble() * (SMS.MaximumDistance - SMS.MinimumDistance) + SMS.MinimumDistance);
            }
            else
            {
                triggerDistance = car.DistanceM + ((float)Viewer.Random.NextDouble() * (SMS.MinimumDistance) + SMS.MinimumDistance);
            }
        }

    } // class ORTSDistanceTravelledTrigger

    /// <summary>
    /// Play this sound immediately when this SoundSource becomes active, or in case no other VariableTriggers are active
    /// </summary>
    public class ORTSInitialTrigger: ORTSTrigger
    {
        private SoundStream SoundStream;

        public ORTSInitialTrigger(SoundStream soundStream, InitialTrigger smsData)
        {
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            SoundStream = soundStream;
        }

        // For pre-compiled activity sound
        public ORTSInitialTrigger(SoundStream soundStream, string wavFileName)
        {
            SoundCommand = ORTSSoundCommand.Precompiled(wavFileName, soundStream);
            SoundStream = soundStream;
        }

        public override void Initialize()
        {
            if (Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;
#if DEBUGSCR
                if (SoundCommand is ORTSSoundPlayCommand && !string.IsNullOrEmpty((SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]))
                    Trace.WriteLine("({0})InitialTrigger: {1}", SoundStream.ALSoundSource.SoundSourceID, (SoundCommand as ORTSSoundPlayCommand).Files[(SoundCommand as ORTSSoundPlayCommand).iFile]);
#endif
            }

            Signaled = true;
        }

    }

    /// <summary>
    /// Play the sound at random times
    /// </summary>
    public sealed class ORTSRandomTrigger : ORTSTrigger
    {
        private Simulator Simulator;
        private RandomTrigger SMS;
        private double triggerAtSeconds;
        private SoundStream SoundStream;

        public ORTSRandomTrigger(SoundStream soundStream, RandomTrigger smsData)
        {
            SoundStream = soundStream;
            SMS = smsData;
            Simulator = soundStream.SoundSource.Viewer.Simulator;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            UpdateTriggerAtSeconds();
        }

        public override void TryTrigger()
        {
            if (Simulator.ClockTime > triggerAtSeconds)
            {
                Signaled = true;
                if (Enabled)
                {
                    SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                    SoundCommand.Run();
                    float volume = (float)Viewer.Random.NextDouble() * (SMS.MaximumVolume - SMS.MinimumVolume) + SMS.MinimumVolume;
                    SoundStream.Volume = volume;
                    SoundStream.LastTriggered = this;
                }
                UpdateTriggerAtSeconds();
            }
            else
            {
                Signaled = false;
            }
        }

        /// <summary>
        /// Calculate new random time till the next triggering action
        /// </summary>
        private void UpdateTriggerAtSeconds()
        {
            double interval = Viewer.Random.NextDouble() * (SMS.MaximumDelay - SMS.MinimumDelay) + SMS.MinimumDelay;
            triggerAtSeconds = Simulator.ClockTime + interval;
        }

    }  // class RandomTrigger

    /// <summary>
    /// Control sounds based on TrainCar variables in the simulator 
    /// </summary>
    public sealed class ORTSVariableTrigger : ORTSTrigger
    {
        private VariableTrigger SMS;
        private MSTSWagon car;
        private SoundStream SoundStream;
        private float StartValue;
        public bool IsBellow;

        public ORTSVariableTrigger(SoundStream soundStream, VariableTrigger smsData)
        {
            SMS = smsData;
            car = soundStream.SoundSource.Car != null ? soundStream.SoundSource.Car : (MSTSWagon)soundStream.SoundSource.Viewer.Camera.AttachedCar;
            SoundStream = soundStream;
            SoundCommand = ORTSSoundCommand.FromMSTS(smsData.SoundCommand, soundStream);
            Initialize();
        }

        public override void  Initialize()
        {
            StartValue = SMS.Event == VariableTrigger.TriggerEvent.DistanceDecrease ? float.MaxValue : 0;

            /*if ((new Variable_Trigger.Events[] { Variable_Trigger.Events.Variable1_Dec_Past,
                Variable_Trigger.Events.Variable1_Inc_Past, Variable_Trigger.Events.Variable2_Dec_Past, 
                Variable_Trigger.Events.Variable2_Inc_Past, Variable_Trigger.Events.Variable3_Dec_Past,
                Variable_Trigger.Events.Variable3_Inc_Past}).Contains(SMS.Event) && SMS.Threshold >= 1)
            {
                SMS.Threshold /= 100f;
            }*/
            IsBellow = StartValue < SMS.Threshold;
        }

        public override void TryTrigger( )
        {
            float newValue = ReadValue();
            bool triggered = false;
            Signaled = false;

            switch (SMS.Event)
            {
                case VariableTrigger.TriggerEvent.DistanceDecrease:
                case VariableTrigger.TriggerEvent.SpeedDecrease:
                case VariableTrigger.TriggerEvent.Variable1Decrease:
                case VariableTrigger.TriggerEvent.Variable2Decrease:
                case VariableTrigger.TriggerEvent.Variable3Decrease:
                case VariableTrigger.TriggerEvent.BrakeCylinderDecrease:
                case VariableTrigger.TriggerEvent.CurveForceDecrease:
                    if (newValue < SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold <= StartValue)
                            triggered = true;
                    }
                    break;
                case VariableTrigger.TriggerEvent.DistanceIncrease:
                case VariableTrigger.TriggerEvent.SpeedIncrease:
                case VariableTrigger.TriggerEvent.Variable1Increase:
                case VariableTrigger.TriggerEvent.Variable2Increase:
                case VariableTrigger.TriggerEvent.Variable3Increase:
                case VariableTrigger.TriggerEvent.BrakeCylinderIncrease:
                case VariableTrigger.TriggerEvent.CurveForceIncrease:
                    if (newValue > SMS.Threshold)
                    {
                        Signaled = true;
                        if (SMS.Threshold >= StartValue)
                            triggered = true;
                    }
                    break;
            }

            //Signaled = triggered;

            StartValue = newValue;
            IsBellow = newValue < SMS.Threshold;

            if (triggered && Enabled)
            {
                SoundStream.RepeatedTrigger = this == SoundStream.LastTriggered;
                SoundCommand.Run();
                SoundStream.LastTriggered = this;

#if DEBUGSCR
                ORTSStartLoop sl = SoundCommand as ORTSStartLoop;
                if (sl != null)
                {
                    Trace.WriteLine("({0})StartLoop ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), sl.Files[sl.iFile]);
                }
                ORTSStartLoopRelease slr = SoundCommand as ORTSStartLoopRelease;
                if (slr != null)
                {
                    Trace.WriteLine("({0})StartLoopRelease ({1} {2}): {3} ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString(), slr.Files[slr.iFile]);
                }
                ORTSReleaseLoopRelease rlr = SoundCommand as ORTSReleaseLoopRelease;
                if (rlr != null)
                {
                    Trace.WriteLine("({0})ReleaseLoopRelease ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
                ORTSReleaseLoopReleaseWithJump rlrwj = SoundCommand as ORTSReleaseLoopReleaseWithJump;
                if (rlrwj != null)
                {
                    Trace.WriteLine("({0})ReleaseLoopReleaseWithJump ({1} {2}) ", SoundStream.ALSoundSource.SoundSourceID, SMS.Event.ToString(), SMS.Threshold.ToString());
                }
#endif
            }
        }

        /// <summary>
        /// Read the desired variable either from the attached TrainCar, or the distance to sound source
        /// </summary>
        /// <returns></returns>
        private float ReadValue()
        {
            switch (SMS.Event)
            {
                case VariableTrigger.TriggerEvent.DistanceDecrease:
                case VariableTrigger.TriggerEvent.DistanceIncrease:
                    return SoundStream.SoundSource.DistanceSquared;
                case VariableTrigger.TriggerEvent.SpeedDecrease:
                case VariableTrigger.TriggerEvent.SpeedIncrease:
                    return car.AbsSpeedMpS;
                case VariableTrigger.TriggerEvent.Variable1Decrease:
                case VariableTrigger.TriggerEvent.Variable1Increase:
                    return car.Variable1;
                case VariableTrigger.TriggerEvent.Variable2Decrease:
                case VariableTrigger.TriggerEvent.Variable2Increase:
                    return car.Variable2;
                case VariableTrigger.TriggerEvent.Variable3Decrease:
                case VariableTrigger.TriggerEvent.Variable3Increase:
                    return car.Variable3;
                case VariableTrigger.TriggerEvent.BrakeCylinderDecrease:
                case VariableTrigger.TriggerEvent.BrakeCylinderIncrease:
                    return car.BrakeSystem.GetCylPressurePSI();
                case VariableTrigger.TriggerEvent.CurveForceDecrease:
                case VariableTrigger.TriggerEvent.CurveForceIncrease:
                    return (float)car.CurveForceNFiltered;
                default:
                    return 0;
            }
        }

    }  // class VariableTrigger


/////////////////////////////////////////////////////////
// SOUND COMMANDS
/////////////////////////////////////////////////////////
    

    /// <summary>
    /// Start playing the whole sound stream once, then stop
    /// </summary>
    public class ORTSPlayOneShot : ORTSSoundPlayCommand
    {
        public ORTSPlayOneShot(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream, mstsSoundPlayCommand)
        {
        }
        // precompiled version for activity sounds
        public ORTSPlayOneShot(SoundStream ortsStream, string wavFileName)
            : base(ortsStream, wavFileName)
        {
        }

        public override void Run()
        {
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.OneShot, ORTSStream.SoundSource.IsExternal, ORTSStream.RepeatedTrigger);
            }
        }
    } 

    /// <summary>
    /// Start looping the whole stream, release it only at the end
    /// </summary>
    public class ORTSStartLoop : ORTSSoundPlayCommand
    {
        public ORTSStartLoop( SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand )
            : base( ortsStream, mstsSoundPlayCommand )
        {
        }
        public override void  Run( )
        {
            // Support for Loop functions - by GeorgeS
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.Loop, ORTSStream.SoundSource.IsExternal, false);
            }
        }
    } 

    /// <summary>
    /// Release the sound by playing the looped sustain part till its end, then play the last part
    /// </summary>
    public class ORTSReleaseLoopRelease : ORTSSoundCommand
    {
        public ORTSReleaseLoopRelease(SoundStream ortsStream)
            : base(ortsStream)
        {
        }
        
        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.Release, ORTSStream.SoundSource.IsExternal, false);
        }
    }

    /// <summary>
    /// Start by playing the first part, then start looping the sustain part of the stream
    /// </summary>
    public class ORTSStartLoopRelease : ORTSSoundPlayCommand
    {
        public ORTSStartLoopRelease(SoundStream ortsStream, SoundPlayCommand mstsStartLoopRelease)
            : base(ortsStream, mstsStartLoopRelease)
        {
        }

        // Support for Loop functions - by GeorgeS
        public override void Run()
        {
            string p = GetNextFile();
            if (!string.IsNullOrEmpty(p))
            {
                if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                    ORTSStream.ALSoundSource.Queue(p, PlayMode.LoopRelease, ORTSStream.SoundSource.IsExternal, ORTSStream.IsReleasedWithJump);
            }
        }
    }

    /// <summary>
    /// Release the sound by playing the looped sustain part till the next cue point, then jump to the last part and play that  
    /// </summary>
    public class ORTSReleaseLoopReleaseWithJump : ORTSSoundCommand
    {
        public ORTSReleaseLoopReleaseWithJump(SoundStream ortsStream)
            : base(ortsStream)
        {
        }

        public override void Run()
        {
            if (ORTSStream != null && ORTSStream.ALSoundSource != null)
                ORTSStream.ALSoundSource.Queue("", PlayMode.ReleaseWithJump, ORTSStream.SoundSource.IsExternal, true);
        }
    }

    /// <summary>
    /// Shut down this stream trigger 
    /// </summary>
    public class ORTSDisableTrigger : ORTSSoundCommand
    {
        private int TriggerIndex;  // index into the stream's trigger list 

        public ORTSDisableTrigger(SoundStream ortsStream, TriggerCommand smsData )
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerId - 1;
        }

        public override void Run()
        {
            if (TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = false;
        }
    }

    /// <summary>
    /// Re-enable this stream trigger
    /// </summary>
    public class ORTSEnableTrigger : ORTSSoundCommand
    {
        private int TriggerIndex;

        public ORTSEnableTrigger(SoundStream ortsStream, TriggerCommand smsData)
            : base(ortsStream)
        {
            TriggerIndex = smsData.TriggerId - 1;
        }

        public override void Run()
        {
            if ( TriggerIndex >= 0 && TriggerIndex < ORTSStream.Triggers.Count)
                ORTSStream.Triggers[TriggerIndex].Enabled = true;
        }
    }

    /// <summary>
    /// Set Volume of Stream
    /// </summary>
    public class ORTSSetStreamVolume : ORTSSoundCommand
    {
        private float Volume;

        public ORTSSetStreamVolume(SoundStream ortsStream, StreamVolumeCommand smsData)
            : base(ortsStream)
        {
            Volume = smsData.Volume;
        }

        public override void Run()
        {
            ORTSStream.Volume = Volume;
        }
    }

    /// <summary>
    /// Used when the SMS file sound command is missing or malformed
    /// </summary>
    public class ORTSNoOp : ORTSSoundCommand
    {
        public ORTSNoOp()
            : base(null)
        {
        }
        public override void Run()
        {
        }
    }

    /// <summary>
    /// A base class for all sound commands
    /// Defines that they all have a stream and a 'Run()' function
    /// </summary>
    public abstract class ORTSSoundCommand
    {
        /// <summary>
        /// The Stream in .sms file it belongs to
        /// </summary>
        protected SoundStream ORTSStream;

        public ORTSSoundCommand(SoundStream ortsStream)
        {
            ORTSStream = ortsStream;
        }

        /// <summary>
        /// Put the command into stream's queue, or set its volume, or enable/disable other commands
        /// </summary>
        public abstract void Run();


        /// <summary>
        /// Create a sound command based on the sound command variable of a trigger in an SMS file.
        /// </summary>
        /// <param name="mstsSoundCommand"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand FromMSTS(SoundCommand mstsSoundCommand, SoundStream soundStream)
        {
            if (mstsSoundCommand == null)
            {
                return new ORTSNoOp();
            }
            else if (mstsSoundCommand is SoundPlayCommand playCommand)
            {
                switch (playCommand.CommandType)
                {
                    case SoundPlayCommand.SoundCommandType.PlayOneShot:
                        return new ORTSPlayOneShot(soundStream, playCommand);
                    case SoundPlayCommand.SoundCommandType.StartLoop:
                        return new ORTSStartLoop(soundStream, playCommand);
                    case SoundPlayCommand.SoundCommandType.StartLoopRelease:
                        return new ORTSStartLoopRelease(soundStream, playCommand);
                }
            }
            else if (mstsSoundCommand is LoopRelease releaseCommand)
            {
                switch (releaseCommand.ReleaseMode)
                {
                    case LoopRelease.ReleaseType.Release:
                        return new ORTSReleaseLoopRelease(soundStream);
                    case LoopRelease.ReleaseType.ReleaseWithJump:
                        return new ORTSReleaseLoopReleaseWithJump(soundStream);
                }
            }
            else if (mstsSoundCommand is StreamVolumeCommand)
            {
                return new ORTSSetStreamVolume(soundStream, (StreamVolumeCommand)mstsSoundCommand);
            }
            else if (mstsSoundCommand is TriggerCommand triggerCommand)
            {
                switch (triggerCommand.Trigger)
                {
                    case TriggerCommand.TriggerType.Disable:
                        return new ORTSDisableTrigger(soundStream, triggerCommand);
                    case TriggerCommand.TriggerType.Enable:
                        return new ORTSEnableTrigger(soundStream, triggerCommand);
                }
            }
            throw new ArgumentException("Unexpected soundCommand type " + mstsSoundCommand.GetType().ToString() + " in " + soundStream.SoundSource.SMSFolder, "mstsSoundCommand");
        }


        /// <summary>
        /// Create a pre-compiled sound command for activity files.
        /// </summary>
        /// <param name="wavFilePath"></param>
        /// <param name="soundStream"></param>
        /// <returns></returns>
        public static ORTSSoundCommand Precompiled(string wavFileName, SoundStream soundStream)
        {
            return new ORTSPlayOneShot(soundStream, wavFileName);        
        }

    }// ORTSSoundCommand


    /// <summary>
    /// A base class for commands that play a sound.
    /// Provides for selecting the sound from multiple files
    /// using a random or sequential selection strategy.
    /// </summary>
    public abstract class ORTSSoundPlayCommand : ORTSSoundCommand
    {
        /// <summary>
        /// File names to select from for playing
        /// </summary>
        public IList<string> Files { get; private set; }
        /// <summary>
        /// How to select from available files
        /// </summary>
        protected SoundPlayCommand.Selection SelectionMethod;
        /// <summary>
        /// Index of the file to play inside <see cref="Files"/> vector
        /// </summary>
        public int iFile;

        public ORTSSoundPlayCommand(SoundStream ortsStream, SoundPlayCommand mstsSoundPlayCommand)
            : base(ortsStream)
        {
            Files = mstsSoundPlayCommand?.Files;
            SelectionMethod = mstsSoundPlayCommand.SelectionMethod;
        }

        // precompiled version for activity sounds
        public ORTSSoundPlayCommand(SoundStream ortsStream, string wavFileName)
            : base(ortsStream)
        {
            Files = new List<string>() { wavFileName };
            SelectionMethod = SoundPlayCommand.Selection.Sequential;
        }

        /// <summary>
        /// Select a file from the Files list using the SelectionMethod
        /// </summary>
        /// <returns>File name with full path </returns>
        protected string GetNextFile()
        {
            if (SelectionMethod == SoundPlayCommand.Selection.Sequential)
            {
                ++iFile;
                if (iFile >= Files.Count)
                    iFile = 0;
            }
            else if (SelectionMethod == SoundPlayCommand.Selection.Random)
            {
                iFile = Viewer.Random.Next(Files.Count);
            }

            string[] pathArray = {  Simulator.Instance.RouteFolder.SoundFolder,
                                    ORTSStream.SoundSource.SMSFolder,
                                    Simulator.Instance.RouteFolder.ContentFolder.SoundFolder };
            return FolderStructure.FindFileFromFolders(pathArray, Files[iFile]) ?? string.Empty;
        }
    }

    public class WorldSounds
    {
        private Dictionary<string, IList<WorldSoundRegion>> SoundRegions = new Dictionary<string, IList<WorldSoundRegion>>();
        private Viewer Viewer;
        private SoundSource ss;

        public WorldSounds(Viewer viewer)
        {
            Viewer = viewer;
        }

        public int GetTType(TDBObjects tdbObjs)
        {
            int retval = 0;
            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;
            float prevDist;
            float nextDist;

            List<int> validitems = (from lwsr in SoundRegions.Values
                                    from wsr in lwsr
                                    from i in wsr.TrackNodes
                                    select i).Distinct().ToList();

            TrackItem prev = tdbObjs.FindPrevItem<SoundRegionItem>(out prevDist, validitems);
            TrackItem next = tdbObjs.FindNextItem<SoundRegionItem>(out nextDist, validitems);

            if (prev != null)
            {
                prevItem = (from lwsr in SoundRegions.Values
                            from wsr in lwsr
                            where wsr.TrackNodes.Contains((int)prev.TrackItemId)
                            select wsr).FirstOrDefault();
            }

            if (next != null)
            {
                nextItem = (from lwsr in SoundRegions.Values
                            from wsr in lwsr
                            where wsr.TrackNodes.Contains((int)next.TrackItemId)
                            select wsr).FirstOrDefault();
            }

            if (prevItem != null && nextItem != null)
            {
                if (prevItem.TrackType == nextItem.TrackType)
                {
                    retval = prevItem.TrackType;
                }
                else if (nextDist < 10)
                {
                    retval = int.MaxValue;
                }
            }

            return retval;
        }

        public int GetTType(Simulation.Physics.Train train, out float outPrevDist, out float outNextDist)
        {
            int retval = 0;
            Traveller traveller;
            Traveller tmp;
            outPrevDist = -1;
            outNextDist = -1;

            if (train.SpeedMpS >= 0)
            {
                traveller = new Traveller(train.FrontTDBTraveller);
            }
            else
            {
                traveller = new Traveller(train.RearTDBTraveller, Traveller.TravellerDirection.Backward);
            }

            TrackDB trackDB = Viewer.Simulator.TrackDatabase.TrackDB;
            TrackItem[] trItems = trackDB.TrackItems;

            WorldSoundRegion prevItem = null;
            WorldSoundRegion nextItem = null;

            float prevDist = float.MaxValue;
            float nextDist = float.MaxValue;
            float d;

            lock (SoundRegions)
            {
                // Check every sound region's all track nodes
                foreach (List<WorldSoundRegion> lwsr in SoundRegions.Values)
                {
                    foreach (WorldSoundRegion wsr in lwsr)
                    {
                        foreach (int trNode in wsr.TrackNodes)
                        {
                            if (trItems[trNode] is SoundRegionItem)
                            {
                                tmp = new Traveller(traveller);

                                // Try to find forward
                                d = tmp.DistanceTo(trItems[trNode].Location, 8192);
                                
                                if (d != -1)
                                {
                                    // This is nearer than previous one
                                    if (d < nextDist)
                                    {
                                        nextDist = d;
                                        nextItem = wsr;
                                    }
                                    // Or at exactly the same distance
                                    else if (d == nextDist)
                                    {
                                        if (traveller.Direction == tmp.Direction)
                                            tmp.ReverseDirection();

                                        // If faces toward us then it is applicable
                                        if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                        {
                                            nextDist = d;
                                            nextItem = wsr;
                                        }
                                    }
                                }
                                else
                                {
                                    // Not found forward, check backward
                                    tmp = new Traveller(traveller, Traveller.TravellerDirection.Backward);

                                    d = tmp.DistanceTo(trItems[trNode].Location, 8192);
                                    if (d != -1)
                                    {
                                        // It is nearer than previous
                                        if (d < prevDist)
                                        {
                                            prevDist = d;
                                            prevItem = wsr;
                                        }
                                        else if (d == prevDist)
                                        {
                                            if (traveller.Direction != tmp.Direction)
                                                tmp.ReverseDirection();

                                            // Applicable if faces with us
                                            if (Math.Abs(tmp.RotY - wsr.RotY) < .35)
                                            {
                                                prevDist = d;
                                                prevItem = wsr;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Have before and behind us
            if (prevItem != null && nextItem != null)
            {
                // Between same type, means we are in a sound region
                if (prevItem.TrackType == nextItem.TrackType)
                {
                    // return one of those, doesn't matter which.
                    retval = prevItem.TrackType;
                    outPrevDist = prevDist;
                    outNextDist = nextDist;
                }
                else if (nextDist < 10)
                {
                    // We are between different regions and the next is very near
                    // This case we won't change to default, unnecessary to that short period of time
                    // int.MaxValue means do not change the current region even if we left it
                    retval = int.MaxValue;
                }
                //  they are different types and far from each other
                //  So we are in a neutral zone, retval is 0, default track type
            }
            else if (prevItem != null)
            {
                // only one, take it!
                retval = prevItem.TrackType;
                outPrevDist = prevDist;
            }
            else if (nextItem != null)
            {
                // only one, take it!
                retval = nextItem.TrackType;
                outNextDist = nextDist;
            }
            //  - Missing items before or behind us, maintain last sound
            else
            {
                retval = int.MaxValue;
            }
            return retval;
        }

        public void AddByTile(int TileX, int TileZ)
        {
            string name = Path.Combine(Viewer.Simulator.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s");
            WorldSoundFile wf = new WorldSoundFile(name, Viewer.Simulator.TrackDatabase.TrackDB.TrackItems);
            if (wf.TrackItemSound != null)
            {
                string[] pathArray = { Viewer.Simulator.RouteFolder.SoundFolder, Viewer.Simulator.RouteFolder.ContentFolder.SoundFolder };

                var ls = new List<SoundSourceBase>();
                foreach (var fss in wf.TrackItemSound.SoundSources)
                {
                    WorldLocation wl = new WorldLocation(TileX, TileZ, fss.Position);
                    var fullPath = FolderStructure.FindFileFromFolders(pathArray, fss.FileName);
                    if (fullPath != null)
                    {
                        ss = new SoundSource(Viewer, wl, SoundEventSource.None, fullPath, true);
                        if (ss != null)
                            ls.Add(ss);
                    }
                }
                Viewer.SoundProcess.AddSoundSources(name, ls);

                lock (SoundRegions)
                {
                    if (!SoundRegions.ContainsKey(name))
                    {
                        SoundRegions.Add(name, wf.TrackItemSound.SoundRegions);
                    }
                }
            }
        }

        public void RemoveByTile(int TileX, int TileZ)
        {
            string name = Path.Combine(Viewer.Simulator.RouteFolder.WorldFolder, WorldFile.WorldFileNameFromTileCoordinates(TileX, TileZ) + "s");
            Viewer.SoundProcess.RemoveSoundSources(name);
            lock (SoundRegions)
            {
                if (SoundRegions.ContainsKey(name))
                {
                    SoundRegions.Remove(name);
                }
            }
        }
    }

    public class TDBObjects
    {
        private MSTSWagon _car;
        private TrackNode[] trackNodes;
        private TrackItem[] trItems;

        public TDBObjects(MSTSWagon Car, Viewer Viewer)
        {
            _car = Car;
            trackNodes = Viewer.Simulator.TrackDatabase.TrackDB.TrackNodes;
            trItems = Viewer.Simulator.TrackDatabase.TrackDB.TrackItems;
        }

        private AIPathNode FindNode()
        {
            AIPathNode retval = null;
            return retval;
        }

        private AIPathNode GetNextNode(AIPathNode node)
        {
            if (node.NextMainNode == null)
                return node.NextSidingNode;
            else
                return node.NextMainNode;
        }

        private AIPathNode GetPrevNode(AIPathNode node)
        {
            AIPathNode retval = null;
            AIPathNode p = node;
            return retval;
        }

        private int GetTVNIndex(AIPathNode node)
        {
            if (node == null)
                return -1;

            if (node.NextMainNode == null)
                return node.NextSidingTVNIndex;
            else
                return node.NextMainTVNIndex;
        }

        public TrackItem FindNextItem<T>(out float distance)
            where T : TrackItem
        {
            Traveller traveller = _car.Train.FrontTDBTraveller;
            return FindItem<T>(traveller, GetNextNode, out distance, null);
        }

        public TrackItem FindNextItem<T>(out float distance, List<int> validitems)
            where T : TrackItem
        {
            Traveller traveller = _car.Train.FrontTDBTraveller;
            return FindItem<T>(traveller, GetNextNode, out distance, validitems);
        }

        public TrackItem FindPrevItem<T>(out float distance)
            where T : TrackItem
        {
            Traveller traveller = new Traveller(_car.Train.FrontTDBTraveller, Traveller.TravellerDirection.Backward);
            return FindItem<T>(traveller, GetPrevNode, out distance, null);
        }

        public TrackItem FindPrevItem<T>(out float distance, List<int> validitems)
            where T : TrackItem
        {
            Traveller traveller = new Traveller(_car.Train.FrontTDBTraveller, Traveller.TravellerDirection.Backward);
            return FindItem<T>(traveller, GetPrevNode, out distance, validitems);
        }

        private TrackItem FindItem<T>(Traveller traveller, Func<AIPathNode, AIPathNode> move, out float distance, List<int> validitems)
            where T : TrackItem
        {
            T Item = null;
            int currentNode;
            AIPathNode aiNode = FindNode();
            currentNode = GetTVNIndex(aiNode);
            distance = float.MaxValue;

            while (aiNode != null && currentNode != -1)
            {
                if (trackNodes[currentNode] is TrackVectorNode trackVectorNode)
                {
                    for (int i = 0; i < trackVectorNode.TrackItemIndices.Length; i++)
                    {
                        if ((trItems[trackVectorNode.TrackItemIndices[i]]) is T item && validitems != null && validitems.Contains((int)item.TrackItemId))
                        {
                            float dist = traveller.DistanceTo(item.Location);
                            if (dist > 0)
                            {
                                if (dist < distance)
                                {
                                    distance = dist;
                                    Item = item;
                                }
                            }
                        }
                    }

                    if (Item != null)
                        return Item;
                }

                aiNode = move(aiNode);
                currentNode = GetTVNIndex(aiNode);
            }

            return null;
        }
    }
    public class ORTSActSoundSources
    {
        public ORTSActSoundSources( )
        {
        }

        public void Update()
        {
            if (Simulator.Instance.ActivityRun == null || Simulator.Instance.ActivityRun.triggeredEventWrapper == null || 
                (Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.SoundFile == null && (Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes == null
                || Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes.ActivitySound == null))) 
                return;
            var localEventID = Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.ID;
            string ORTSActSoundFile;
            OrtsActivitySoundFileType ORTSActSoundFileType;
            ActivitySound activitySound = null;
            if (Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes == null
                || Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes.ActivitySound == null)
            {
                ORTSActSoundFile = Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.SoundFile;
                ORTSActSoundFileType = Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.SoundFileType;
            }
            else
            {
                activitySound = Simulator.Instance.ActivityRun.triggeredEventWrapper.ParsedObject.Outcomes.ActivitySound;
                ORTSActSoundFile = activitySound.SoundFile;
                ORTSActSoundFileType = activitySound.SoundFileType;
            }
            var train = Simulator.Instance.ActivityRun.triggeredEventWrapper.Train;
            Simulator.Instance.ActivityRun.triggeredEventWrapper = null;
            var extension = Path.GetExtension(ORTSActSoundFile);
            SoundSource ActivitySounds;
            switch (extension)
            {
                case ".sms":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(Program.Viewer, SoundEventSource.InGame, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(Program.Viewer, playerLoco, ORTSActSoundFile);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == Camera.Styles.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(Program.Viewer, selectedWagon, ORTSActSoundFile);
                                Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = (train == Program.Viewer.Simulator.PlayerLocomotive.Train) ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];                       
//                            string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(Program.Viewer, loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(Program.Viewer, activitySound.Location.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        default:
                            break;
                    }
                    break;
                case ".wav":
                    switch (ORTSActSoundFileType)
                    {
                        case OrtsActivitySoundFileType.Everywhere:
                            ActivitySounds = new SoundSource(Program.Viewer, SoundEventSource.InGame, ORTSActSoundFile, ORTSActSoundFileType, true, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Cab:
                            var playerLoco = (MSTSWagon)Program.Viewer.Simulator.PlayerLocomotive;
                            ActivitySounds = new SoundSource(Program.Viewer, playerLoco, ORTSActSoundFile, ORTSActSoundFileType, true);
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Pass:
                            if (Program.Viewer.Camera.Style == Camera.Styles.Passenger && Program.Viewer.Camera.AttachedCar != null)
                            {
                                var selectedWagon = (MSTSWagon)Program.Viewer.Camera.AttachedCar;
                                ActivitySounds = new SoundSource(Program.Viewer, selectedWagon, ORTSActSoundFile, ORTSActSoundFileType, true);
                                Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            }
                            break;
                        case OrtsActivitySoundFileType.Ground:
                            var loco = (train == Program.Viewer.Simulator.PlayerLocomotive.Train) ?
                                Program.Viewer.Simulator.PlayerLocomotive : train.Cars[0];
 //                           string wsName = Program.Viewer.Simulator.RoutePath + @"\WORLD\" + WorldFile.WorldFileNameFromTileCoordinates(worldLocation.TileX, worldLocation.TileZ) + "s";
                            ActivitySounds = new SoundSource(Program.Viewer, loco.WorldPosition.WorldLocation.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true, ORTSActSoundFileType, true);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        case OrtsActivitySoundFileType.Location:
                            ActivitySounds = new SoundSource(Program.Viewer, activitySound.Location.ChangeElevation(3.0f), SoundEventSource.None, ORTSActSoundFile, true, ORTSActSoundFileType, true);// Sound does not come from earth!
                            Program.Viewer.SoundProcess.AddSoundSources(localEventID, new List<SoundSourceBase>() { ActivitySounds });
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
            return;
        }
     }
}

